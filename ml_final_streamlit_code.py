# -*- coding: utf-8 -*-
"""ML Final Streamlit Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T5l65PrtylPCdPTbJIVFfGWBKrYMF0TD
"""

import streamlit as st
import numpy as np
import cv2
from shapely.geometry import box
from shapely.ops import unary_union
from shapely.geometry import Polygon
from deepforest import main

# === Streamlit App ===
st.title("Tree Canopy Detection & Clearing Cost Estimator ðŸŒ³")

# Sidebar for settings
st.sidebar.header("Settings")
altitude_ft = st.sidebar.number_input("Altitude (ft)", value=400.0)
sensor_width_mm = st.sidebar.number_input("Sensor width (mm)", value=13.2)
focal_length_mm = st.sidebar.number_input("Focal length (mm)", value=8.8)
cost_per_m2 = st.sidebar.number_input("Cost per mÂ² to clear", value=5.0)

uploaded_image = st.file_uploader("Upload an aerial image", type=["jpg", "jpeg", "png"])

if uploaded_image:
    # Read image
    image = cv2.imdecode(np.frombuffer(uploaded_image.read(), np.uint8), cv2.IMREAD_COLOR)
    img_height, img_width = image.shape[:2]

    # === Load DeepForest Model ===
    model = main.deepforest()
    model.use_release()

    # Run prediction
    predictions = model.predict_image(image)
    total_tree_area_px = 0
    polygons = []

    for _, row in predictions.iterrows():
        xmin, ymin, xmax, ymax = row[["xmin", "ymin", "xmax", "ymax"]]
        total_tree_area_px += (xmax - xmin) * (ymax - ymin)
        polygons.append(box(xmin, ymin, xmax, ymax))
        cv2.rectangle(image, (int(xmin), int(ymin)), (int(xmax), int(ymax)), (0, 255, 0), 2)

    # === Merge polygons with buffer for smoothing ===
    merged_canopy = unary_union(polygons).buffer(10)  # Buffer in pixels for smooth shape
    merged_canopy_area_px = merged_canopy.area

    # === Pixel resolution (GSD) calculation ===
    altitude_m = altitude_ft * 0.3048
    pixel_resolution_m = (sensor_width_mm * altitude_m * 1000) / (focal_length_mm * img_width)

    # === Area in mÂ² ===
    merged_canopy_area_m2 = merged_canopy_area_px * (pixel_resolution_m ** 2)

    # === Cost estimation ===
    estimated_cost = merged_canopy_area_m2 * cost_per_m2

    # === Display results ===
    st.subheader("Results")
    st.write(f"**Pixel Resolution (GSD):** {pixel_resolution_m:.4f} m/pixel")
    st.write(f"**Estimated Tree-Covered Area:** {merged_canopy_area_m2:.2f} mÂ²")
    st.write(f"**Estimated Clearing Cost:** ${estimated_cost:,.2f}")

    # Draw merged polygon on image
    overlay = image.copy()
    if merged_canopy.geom_type == "Polygon":
        coords = np.array(merged_canopy.exterior.coords, dtype=np.int32)
        cv2.polylines(overlay, [coords], True, (0, 0, 255), 2)
    elif merged_canopy.geom_type == "MultiPolygon":
        for poly in merged_canopy:
            coords = np.array(poly.exterior.coords, dtype=np.int32)
            cv2.polylines(overlay, [coords], True, (0, 0, 255), 2)

    st.image(cv2.cvtColor(overlay, cv2.COLOR_BGR2RGB), caption="Detections with Merged Canopy", use_column_width=True)